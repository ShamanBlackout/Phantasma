"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutOfBoundsMessageFactory = exports.EndOfStreamMessageFactory = exports.InvalidUtf8CharacterMessageFactory = exports.EncodingMessageFactory = void 0;
const Encoding_1 = require("../Encoding");
const allEncodings = Object.values(Encoding_1.Encoding).join(', ');
/** @ignore*/
exports.EncodingMessageFactory = {
    unknownEncoding: function (encoding) {
        return `'${encoding}' is not a supported encoding, use one of ${allEncodings} instead.`;
    },
};
/** @ignore*/
exports.InvalidUtf8CharacterMessageFactory = {
    invalidLeadingByte: function (readByte, position) {
        return `Invalid leading byte found at position ${position}, expected prefix of 0x, 11x, 111x or 111x, got '${readByte.toString(2).padStart(8, '0')}' instead.`;
    },
    notContinuationByte: function (sequenceStartPosition, byteIndex, readByte) {
        return `Byte #${byteIndex + 1} in UTF8 sequence starting at ${sequenceStartPosition} was expected to be a continuation byte, got '${readByte.toString(2).padStart(8, '0')}' instead.`;
    },
};
/** @ignore*/
exports.EndOfStreamMessageFactory = {
    readStringZeroBytesLeft: function () {
        return `readString requires at least one byte to be left in the stream, but 0 bytes are remaining.`;
    },
    readStringLengthNotEnoughBytesLeft: function () {
        return `readString ran out of stream when reading length prefix.`;
    },
    readStringTooLongPrefix: function () {
        return `readString encountered a string prefix that takes more than 5 bytes`;
    },
    readStringTooLongLeft: function (expectedLength, remainingLength) {
        return `readString failed when trying to read tring of length ${expectedLength} byte(s), only ${remainingLength} byte(s) are remaining.`;
    },
    readCharZeroBytesLeft: function () {
        return `readChar requires at least one byte to be left in the stream, but 0 bytes are remaining.`;
    },
    utf8NotEnoughBytesInBuffer: function (position, bytesExpected, bytesRemaining) {
        return `Utf8 sequence at position ${position} is ${bytesExpected} bytes long, but only ${bytesRemaining} byte(s) are left in the buffer.`;
    },
    utf8NotEnoughBytesAllowed: function (position, bytesExpected, bytesRemaining) {
        return `Utf8 sequence at position ${position} is ${bytesExpected} bytes long, but only ${bytesRemaining} more byte(s) are allowed to be read.`;
    },
    notEnoughBytesInBuffer: function (bytesExpected, bytesRemaining, operationName) {
        return `${operationName} expects ${bytesExpected} bytes to be left in the stream, but only ${bytesRemaining} byte(s) are remaining.`;
    },
};
/** @ignore */
exports.OutOfBoundsMessageFactory = {
    numberOutsideRange: function (numberName, minimumValue, maximumValue, givenValue) {
        return `Number of type '${numberName}' must be between ${minimumValue} and ${maximumValue}, got ${givenValue} instead.`;
    }
};
//# sourceMappingURL=ErrorMessageFactory.js.map