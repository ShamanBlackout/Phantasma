"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryWriter = void 0;
const bigInt = require("big-integer");
const Encoding_1 = require("./Encoding");
const Utf8_1 = require("./Utf8");
const OutOfBoundsError_1 = require("./errors/OutOfBoundsError");
const ErrorMessageFactory_1 = require("./errors/ErrorMessageFactory");
const InvalidArgumentError_1 = require("./errors/InvalidArgumentError");
const Numbers_1 = require("./Numbers");
const EncodingError_1 = require("./errors/EncodingError");
/**
 * @ignore
 */
function assertNumberSize(type, minValue, maxValue, givenValue) {
    if (givenValue < minValue || givenValue > maxValue || Number.isNaN(givenValue)) {
        throw new OutOfBoundsError_1.OutOfBoundsError(ErrorMessageFactory_1.OutOfBoundsMessageFactory.numberOutsideRange(type, minValue, maxValue, givenValue));
    }
}
/**
 * @ignore
 */
function assertBigIntSize(type, minValue, maxValue, givenValue) {
    const givenBigInt = bigInt(givenValue);
    if (givenBigInt.lesser(minValue) || givenBigInt.greater(maxValue)) {
        throw new OutOfBoundsError_1.OutOfBoundsError(ErrorMessageFactory_1.OutOfBoundsMessageFactory.numberOutsideRange(type, minValue, maxValue, givenValue));
    }
}
/**
 * A binary stream writer compatible with majority of methods in C#'s [BinaryWriter](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter?view=netframework-4.7.2).
 *
 * All write operations advance the position by the number of bytes that were written.
 *
 * Any time the word _stream_ or _buffer_ is used in the documentation it refers to the internal array that represents the written data.
 */
class BinaryWriter {
    constructor(arg1 = undefined) {
        this._position = 0;
        if (Array.isArray(arg1)) {
            this._buffer = new Array(arg1.length);
            this._length = 0;
            this.writeBytes(arg1);
        }
        else if (arg1 instanceof Uint8Array) {
            this._buffer = Array.from(arg1);
            this._length = this._buffer.length;
        }
        else {
            this._buffer = [];
            this._length = 0;
        }
    }
    /**
     * Length of the written data in bytes
     */
    get length() {
        return this._length;
    }
    /**
     * Current position inside the buffer denoting the place at which the next write operation will happen.
     */
    get position() {
        return this._position;
    }
    /**
     * Changes the position inside the buffer at which the next write operation will happen. Setting it to less than `0` will clamp it to `0`, and setting it
     * to anything more than `length` will clamp it to `length`.
     */
    set position(value) {
        this._position = Math.max(0, Math.min(this._length, value));
    }
    /**
     * Writes one byte, `0x01` for `true` and `0x00` for `false` and advances the position by one byte.
     * @param {boolean} value Boolean to write.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Boolean_)
     */
    writeBoolean(value) {
        this._buffer[this._position++] = value ? 1 : 0;
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes one byte and advances the position by one byte.
     * @param {number} value Byte to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than 0, more than 255, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Byte_)
     */
    writeByte(value) {
        assertNumberSize('byte', Numbers_1.Numbers.BYTE.MIN, Numbers_1.Numbers.BYTE.MAX, value);
        this._buffer[this._position++] = value;
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes the same byte multiple times and advances the position by `repeats` bytes.
     * @param {number} value Byte to write.
     * @param {number} repeats Number of times to write the byte.
     * @throws [[InvalidArgumentError]] Thrown when `repeats` is less than 0, +/- infinity or `NaN`.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than 0, more than 255, +/- infinity or `NaN`.
     */
    writeSameByte(value, repeats) {
        if (Number.isNaN(repeats) || !Number.isFinite(repeats) || repeats < 0) {
            throw new InvalidArgumentError_1.InvalidArgumentError('`repeats` must be a non-negative integer', 'repeats', repeats);
        }
        assertNumberSize('byte', Numbers_1.Numbers.BYTE.MIN, Numbers_1.Numbers.BYTE.MAX, value);
        while (repeats-- > 0) {
            this._buffer[this._position++] = value;
        }
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes the passed array of bytes and advances the position by `bytes`'s length.
     * @param {number[]} bytes Bytes to write.
     * @throws [[OutOfBoundsError]] Thrown when any of the bytes in `bytes` is less than 0, more than 255, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Byte___)
     */
    writeBytes(bytes) {
        for (let i = 0; i < bytes.length; i++) {
            const byte = bytes[i];
            assertNumberSize('byte', Numbers_1.Numbers.BYTE.MIN, Numbers_1.Numbers.BYTE.MAX, byte);
            this._buffer[this._position++] = byte;
        }
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a `signed byte` and advances the position by one byte.
     * @param {number} value Signed byte to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than -128, more than 127, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_SByte_)
     */
    writeSignedByte(value) {
        assertNumberSize('signed byte', Numbers_1.Numbers.SBYTE.MIN, Numbers_1.Numbers.SBYTE.MAX, value);
        this._buffer[this._position++] = value < 0 ? value + 256 : value;
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a `short` and advances the position by two bytes.
     * @param {number} value Short to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than -32,768 more than 32,767, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Int16_)
     */
    writeShort(value) {
        assertNumberSize('short', Numbers_1.Numbers.SHORT.MIN, Numbers_1.Numbers.SHORT.MAX, value);
        this._buffer[this._position++] = value & 0xFF;
        this._buffer[this._position++] = (value >> 8 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes an `unsigned short` and advances the position by two bytes.
     * @param {number} value Unsigned short to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than 0 more than 65,535, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_UInt16_)
     */
    writeUnsignedShort(value) {
        assertNumberSize('unsigned short', Numbers_1.Numbers.USHORT.MIN, Numbers_1.Numbers.USHORT.MAX, value);
        this._buffer[this._position++] = value & 0xFF;
        this._buffer[this._position++] = (value >> 8 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes an `int` and advances the position by four bytes.
     * @param {number} value Int to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than -2,147,483,648 more than 2,147,483,647, +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Int32_)
     */
    writeInt(value) {
        assertNumberSize('int', Numbers_1.Numbers.INT.MIN, Numbers_1.Numbers.INT.MAX, value);
        this._buffer[this._position++] = value & 0xFF;
        this._buffer[this._position++] = (value >> 8 & 0xFF);
        this._buffer[this._position++] = (value >> 16 & 0xFF);
        this._buffer[this._position++] = (value >> 24 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes an `unsigned int` and advances the position by four bytes.
     * @param {number} value Unsigned int to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than 0 more than 4,294,967,295 +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_UInt32_)
     */
    writeUnsignedInt(value) {
        assertNumberSize('unsigned int', Numbers_1.Numbers.UINT.MIN, Numbers_1.Numbers.UINT.MAX, value);
        this._buffer[this._position++] = value & 0xFF;
        this._buffer[this._position++] = (value >> 8 & 0xFF);
        this._buffer[this._position++] = (value >> 16 & 0xFF);
        this._buffer[this._position++] = (value >> 24 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a `long` and advances the position by eight bytes.
     *
     * @remarks
     * JavaScript internally uses `double` to represent all numbers. The smallest and largest number that can be represented without loss of precision are,
     * respectively, −9,007,199,254,740,991 `−(2^53 − 1)` and 9,007,199,254,740,991 `2^53 − 1`, while `long` can hold values between `-2^63` and `2^63 - 1`, while
     * `unsigned long` goes all the way up to `2^64-1`.
     *
     * What happens when you go beyond those limits is that some numbers just cannot be expressed. `9007199254740992+1` is the same as `9007199254740992+1+1+1+1`
     * and if you try to set a variable to `9007199254740993` it just gets rounded down.
     *
     * @param {number|string} value Long to write accepted both as a string (for 100% precision in very low/high numbers) and number, when precision is not a
     * requirement.
     * @throws [[InvalidArgumentError]] Thrown when `value` is `NaN` or +/- infinite.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than -9,223,372,036,854,775,808 more than 9,223,372,036,854,775,807 +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Int64_)
     */
    writeLong(value) {
        if (typeof value === 'number' && (Number.isNaN(value) || !Number.isFinite(value))) {
            throw new InvalidArgumentError_1.InvalidArgumentError('Value cannot be infinite or NaN', 'value', value);
        }
        assertBigIntSize('long', Numbers_1.Numbers.LONG.MIN, Numbers_1.Numbers.LONG.MAX, value.toString());
        const bigint = typeof value === "number"
            ? bigInt(value)
            : bigInt(value);
        const leftHalf = bigint.and(0xFFFFFFFF).toJSNumber();
        const rightHalf = bigint.shiftRight(32).and(0xFFFFFFFF).toJSNumber();
        this._buffer[this._position++] = leftHalf & 0xFF;
        this._buffer[this._position++] = (leftHalf >> 8 & 0xFF);
        this._buffer[this._position++] = (leftHalf >> 16 & 0xFF);
        this._buffer[this._position++] = (leftHalf >> 24 & 0xFF);
        this._buffer[this._position++] = rightHalf & 0xFF;
        this._buffer[this._position++] = (rightHalf >> 8 & 0xFF);
        this._buffer[this._position++] = (rightHalf >> 16 & 0xFF);
        this._buffer[this._position++] = (rightHalf >> 24 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes an `unsigned long` and advances the position by eight bytes. See the remark in [[writeLong]] for details about why strings are preferred.
     *
     * @param {number|string} value Unsigned long to write accepted both as a string (for 100% precision in very low/high numbers) and number, when precision is not a
     * requirement.
     * @throws [[InvalidArgumentError]] Thrown when `value` is `NaN` or +/- infinite.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than 0 more than 18,446,744,073,709,551,615 +/- infinity or `NaN`.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_UInt64_)
     */
    writeUnsignedLong(value) {
        if (typeof value === 'number' && (Number.isNaN(value) || !Number.isFinite(value))) {
            throw new InvalidArgumentError_1.InvalidArgumentError('Value cannot be infinite or NaN', 'value', value);
        }
        assertBigIntSize('unsigned long', Numbers_1.Numbers.ULONG.MIN, Numbers_1.Numbers.ULONG.MAX, value.toString());
        const bigint = typeof value === "number"
            ? bigInt(value)
            : bigInt(value);
        const leftHalf = bigint.and(0xFFFFFFFF).toJSNumber();
        const rightHalf = bigint.shiftRight(32).and(0xFFFFFFFF).toJSNumber();
        this._buffer[this._position++] = leftHalf & 0xFF;
        this._buffer[this._position++] = (leftHalf >> 8 & 0xFF);
        this._buffer[this._position++] = (leftHalf >> 16 & 0xFF);
        this._buffer[this._position++] = (leftHalf >> 24 & 0xFF);
        this._buffer[this._position++] = rightHalf & 0xFF;
        this._buffer[this._position++] = (rightHalf >> 8 & 0xFF);
        this._buffer[this._position++] = (rightHalf >> 16 & 0xFF);
        this._buffer[this._position++] = (rightHalf >> 24 & 0xFF);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a `float` and advances the position by four bytes.
     * @param {boolean} value Float to write.
     * @throws [[OutOfBoundsError]] Thrown when `value` is less than -3.4028235e+38 or more than 3.4028235e+38.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Single_)
     */
    writeFloat(value) {
        if (Number.isFinite(value) && !Number.isNaN(value)) {
            assertNumberSize('float', Numbers_1.Numbers.FLOAT.MIN, Numbers_1.Numbers.FLOAT.MAX, value);
        }
        if (Number.isNaN(value)) {
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0xc0;
            this._buffer[this._position++] = 0xff;
        }
        else {
            const floatBuffer = new Float32Array([value]);
            const uintBuffer = new Uint8Array(floatBuffer.buffer, floatBuffer.byteOffset, 4);
            this._buffer[this._position++] = uintBuffer[0];
            this._buffer[this._position++] = uintBuffer[1];
            this._buffer[this._position++] = uintBuffer[2];
            this._buffer[this._position++] = uintBuffer[3];
        }
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a `double` and advances the position by eight bytes.
     * @param {boolean} value Double to write.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Double_)
     */
    writeDouble(value) {
        if (Number.isNaN(value)) {
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0x00;
            this._buffer[this._position++] = 0xf8;
            this._buffer[this._position++] = 0xff;
        }
        else {
            const floatBuffer = new Float64Array([value]);
            const uintBuffer = new Uint8Array(floatBuffer.buffer, floatBuffer.byteOffset, 8);
            this._buffer[this._position++] = uintBuffer[0];
            this._buffer[this._position++] = uintBuffer[1];
            this._buffer[this._position++] = uintBuffer[2];
            this._buffer[this._position++] = uintBuffer[3];
            this._buffer[this._position++] = uintBuffer[4];
            this._buffer[this._position++] = uintBuffer[5];
            this._buffer[this._position++] = uintBuffer[6];
            this._buffer[this._position++] = uintBuffer[7];
        }
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes a single character in the specified encodng and advances the position by the number of bytes the character takes in that encoding.
     *
     * @param {number|String} character Unicode codepoint of the character to write or a string, in which case only the first character is used.
     * @param {Encoding} encoding Character encoding to use when writing the character.
     * @throws [[InvalidArgumentError]] Thrown when `null` is passed for `character` or when the codepoint passed in `character` is negative, +/- infinite or `NaN`
     * @throws [[EncodingError]] Thrown when unknown or unsupported `encoding` is passed.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Char_)
     */
    writeChar(character, encoding) {
        if (character === null) {
            throw new InvalidArgumentError_1.InvalidArgumentError('Cannot write null string.', 'value', character);
        }
        if (!Encoding_1.isValidEncoding(encoding)) {
            throw new EncodingError_1.EncodingError(ErrorMessageFactory_1.EncodingMessageFactory.unknownEncoding(encoding));
        }
        this._position = Utf8_1.writeUtf8StringFromCodePoints(this._buffer, this._position, typeof character === "number" ? [character] : [character.codePointAt(0)]);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes multiple characters in the specified encodng and advances the position by the number of bytes the charactesr take in that encoding.
     *
     * @param {number[]|String} characters Unicode codepoints of the character to write or a string.
     * @param {Encoding} encoding Character encoding to use when writing the characters.
     * @throws [[InvalidArgumentError]] Thrown when `null` is passed for `character` or when any of the codepoints passed in `characters` is negative, +/- infinite or `NaN`
     * @throws [[EncodingError]] Thrown when unknown or unsupported `encoding` is passed.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_Char___)
     */
    writeChars(characters, encoding) {
        if (characters === null) {
            throw new InvalidArgumentError_1.InvalidArgumentError('Cannot write null string.', 'value', characters);
        }
        if (!Encoding_1.isValidEncoding(encoding)) {
            throw new EncodingError_1.EncodingError(ErrorMessageFactory_1.EncodingMessageFactory.unknownEncoding(encoding));
        }
        this._position = Utf8_1.writeUtf8StringFromCodePoints(this._buffer, this._position, characters);
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Writes length-prefixed multiple characters in the specified encodng and advances the position by the number of bytes the charactesr take in that encoding.
     *
     * @param {number[]|String} value Unicode codepoints of the character to write or a string.
     * @param {Encoding} encoding Character encoding to use when writing the characters.
     * @throws [[InvalidArgumentError]] Thrown when `null` is passed for `character` or when any of the codepoints passed in `characters` is negative, +/- infinite or `NaN`
     * @throws [[EncodingError]] Thrown when unknown or unsupported `encoding` is passed.
     * @link [C# `BinaryWriter.Write(Boolean)` documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write?view=netframework-4.7.2#System_IO_BinaryWriter_Write_System_String_)
     */
    writeString(value, encoding) {
        if (value === null) {
            throw new InvalidArgumentError_1.InvalidArgumentError('Cannot write null string.', 'value', value);
        }
        if (!Encoding_1.isValidEncoding(encoding)) {
            throw new EncodingError_1.EncodingError(ErrorMessageFactory_1.EncodingMessageFactory.unknownEncoding(encoding));
        }
        const tempBuffer = [];
        Utf8_1.writeUtf8StringFromCodePoints(tempBuffer, 0, value);
        let length = tempBuffer.length;
        while (length >= 0x80) {
            this._buffer[this._position++] = (length & 0xFF) | 0x80;
            length >>= 7;
        }
        this._buffer[this._position++] = length;
        for (let i = 0; i < tempBuffer.length; i++) {
            this._buffer[this._position++] = tempBuffer[i];
        }
        this._length = Math.max(this._length, this._position);
    }
    /**
     * Completely clears the underlying buffer and changes `position` and `length` to zero.
     */
    clear() {
        this._position = 0;
        this._length = 0;
    }
    /**
     * Returns the contents of the writer as regular array of bytes.
     * @returns {number[]}
     */
    toArray() {
        return this._buffer.slice(0, this._length);
    }
    /**
     * Returns the contents of the writer as `Uint8Array`
     * @returns {Uint8Array}
     */
    toUint8Array() {
        return new Uint8Array(this.toArray());
    }
}
exports.BinaryWriter = BinaryWriter;
//# sourceMappingURL=BinaryWriter.js.map